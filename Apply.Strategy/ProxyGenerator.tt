<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Runtime.CompilerServices" #>
//https://github.com/dotnet/core/issues/2000


//Import the dependencies !
<# //assembly name="$(SolutionDir)\ExternalDependency\bin\Debug\netstandard2.0\ExternalDependency.dll" #>
<# //import namespace="ExternalDependency" #>


<#
	//Update the list with services you want to proxify
	string[] serviceList = { /*"ExternalService"*/ };

	//Define the assembly where are the previous class you want to proxify
    //var assembly = Assembly.GetAssembly(typeof(ExternalService));
    var assembly = Assembly.GetExecutingAssembly(); //Just to not make it crash, remove this line
    var types = assembly.GetTypes();

	foreach (var classType in types.Where(x => serviceList.Contains(x.Name)))
    {
        string className = classType.Name;
		if(classType.IsInterface && className.StartsWith("I"))
			className = classType.Name.Substring(1);
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Generated on: <#=System.DateTime.Now.ToString()#>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------
using ExternalDependency;
using Mock.Dependency.With.Proxy.Apply.Strategy;
using Mock.Dependency.With.Proxy.Data.Transfer.Objects.Strategies;
using System;
using StructureMap;
using System.Reflection;
//using static Integration.Tests.ProjectWithProxy.ServiceMethodsStrategies.ServiceMethodsIdentifiers;
using StructureMapConfigurationException = StructureMap.StructureMapConfigurationException;

namespace Mock.Dependency.With.Proxy.Apply.Strategy
{
<#
		foreach(var meth in classType.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public))
		{
			var parameters = meth.GetParameters();
			var methodName = meth.Name;
			var returnType = FixUpTypeName(meth.ReturnType);
 
			StringBuilder parameterList = new StringBuilder();
			StringBuilder parameterListWithTypes = new StringBuilder();
			foreach(var parameter in parameters)
			{
				parameterList.Append(parameter.Name);
				parameterListWithTypes.Append(FixUpTypeName(parameter.ParameterType) + " " + parameter.Name);
				if(parameter != parameters.Last())
				{
					parameterList.Append(", ");
					parameterListWithTypes.Append(", ");
				}
			}
#>	
	public interface <#=className#><#=methodName#>Template
	{
		<#=returnType#> <#=methodName#>(<#=parameterListWithTypes#>);
	}
<#
		}
#>

	public partial class <#=(className+"Proxy")#> : ProxyBase, <#=className#>
    {
        private readonly <#=className#> service;
        private readonly MockStrategyRepository mockStrategyQuery;

        public ExternalServiceProxy(MockStrategyRepository mockStrategyQuery, <#=className#> service)
        {
            this.mockStrategyQuery = mockStrategyQuery;
            this.service = service;
        }
<#
		var templatesNames = new List<string>();
		foreach(var meth in classType.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public))
		{
			var param = meth.GetParameters();
 
			var methodName = meth.Name;
			var returnType = FixUpTypeName(meth.ReturnType);
 
			StringBuilder parameterList = new StringBuilder();
			StringBuilder parameterListWithTypes = new StringBuilder();
			foreach(var p in param)
			{
				parameterList.Append(p.Name);
				parameterListWithTypes.Append(FixUpTypeName(p.ParameterType) + " " + p.Name);
				if(p != param.Last())
				{
					parameterList.Append(", ");
					parameterListWithTypes.Append(", ");
				}
			}

			var coma = "";
			if(!string.IsNullOrWhiteSpace(parameterList.ToString()))
				coma = ",";

			var attType = typeof(AsyncStateMachineAttribute);

			var attrib = (AsyncStateMachineAttribute)meth.GetCustomAttribute(attType);

			var asyncText = attrib == null | methodName.EndsWith("Async") ? string.Empty : "async";

			var templateName = className + methodName + "Template";
			templatesNames.Add(templateName);
			if(returnType != "void")
			{
#>

		public <#=asyncText#> <#=returnType#> <#=methodName#>(<#=parameterListWithTypes#>)
        {
           <#=returnType#> returnedValue;

            var mockStrategy = this.mockStrategyQuery.GetMockStrategy(GetId, this.InWantedContext());

            if (NoMockStrategy(mockStrategy))
            {
                returnedValue = this.service.<#=methodName#>(<#=parameterList#>);
            }
            else if (mockStrategy is ObjectStrategy<<#=returnType#>> objectStrategy)
            {
                returnedValue = objectStrategy.MockedObject;
            }
            else if (mockStrategy is SubstituteBehaviorStrategy methodStrategy)
            {
                returnedValue = ApplyMethodMockStrategy<#=methodName#>(methodStrategy <#=coma#> <#=parameterList#>);
            }
            else
            {
                throw new Exception("Current mock strategy is not take in account");
            }

            this.mockStrategyQuery.RemoveStrategy(mockStrategy);

            return returnedValue;
        }
		
		private static <#=returnType#> ApplyMethodMockStrategy<#=methodName#>(SubstituteBehaviorStrategy substituteBehaviorStrategy <#=coma#> <#=parameterListWithTypes#>)
        {
			try
            {
                var serviceSubstitute = ProxyContainer.Container.GetInstance<<#=templateName#>>(substituteBehaviorStrategy.BehaviorName);
				return serviceSubstitute.<#=methodName#>(<#=parameterList#>);
            }
            catch (StructureMapConfigurationException)
            {
                throw new Exception($"Method strategy '{substituteBehaviorStrategy.BehaviorName}' is not defined");
            }            
        }
<#
			} else {
#>

		public <#=asyncText#> void <#=methodName#>(<#=parameterListWithTypes#>)
        {
            var mockStrategy = this.mockStrategyQuery.GetMockStrategy(<#=methodName#>Id, this.InWantedContext());

            if (NoMockStrategy(mockStrategy))
            {
                this.service.<#=methodName#>(<#=parameterList#>);
            }
            else if (mockStrategy is SubstituteBehaviorStrategy methodStrategy)
            {
                ApplyMethodMockStrategy<#=methodName#>(methodStrategy <#=coma#> <#=parameterList#>);
            }
            else
            {
                throw new Exception("Current mock strategy is not take in account");
            }

            this.mockStrategyQuery.RemoveStrategy(mockStrategy);
        }

		private static void ApplyMethodMockStrategy<#=methodName#>(SubstituteBehaviorStrategy substituteBehaviorStrategy <#=coma#> <#=parameterListWithTypes#>)
        {
			try
            {
                var serviceSubstitute = ProxyContainer.Container.GetInstance<<#=templateName#>>(substituteBehaviorStrategy.BehaviorName);
				serviceSubstitute.<#=methodName#>(<#=parameterList#>);
            }
            catch (StructureMapConfigurationException)
            {
                throw new Exception($"Method strategy '{substituteBehaviorStrategy.BehaviorName}' is not defined");
            }
        }
<#
			}
		}
#>
		
		private static bool NoMockStrategy(MockStrategy mockStrategy)
        {
            return mockStrategy is NoMockStrategy || mockStrategy is ForceNoMockStrategy;
        }
	}
	
	public static class ProxyContainer
    {
        private static Container container;
	
        public static Container Container
        {
            get
            {
                if (container == null)
                {
                    container = new Container(c =>
                    {
                        c.Scan(_ =>
                        {
                            _.Assembly(Assembly.GetExecutingAssembly());
<#
							foreach(var templateName in templatesNames) { 
#>
                            _.AddAllTypesOf<<#=templateName#>>().NameBy(x => x.Name);
<#
							}
#>
                        });
                    });
                }
	
                return container;
            }
        }
    }

}
<#
    }
#>    

<#+
void SaveOutput(string outputFileName)
{
    string templateDirectory = Path.GetDirectoryName(Host.TemplateFile);
    string outputFilePath = Path.Combine(templateDirectory, outputFileName);
    File.WriteAllText(outputFilePath, this.GenerationEnvironment.ToString()); 
 
    this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
}

public string FixUpType(Type t)
{
    string type = t.FullName;
    type = type.Replace("System.", "");
 
    switch (type)
    {
        case "String":
            return "string";
        case "Byte":
            return "byte";
        case "Byte[]":
            return "byte[]";
        case "Int16":
            return "short";
        case "Int32":
            return "int";
        case "Int64":
            return "long";
        case "Char":
            return "char";
        case "Single":
            return "float";
        case "Double":
            return "double";
        case "Boolean":
            return "bool";
        case "Decimal":
            return "decimal";
        case "SByte":
            return "sbyte";
        case "UInt16":
            return "ushort";
        case "UInt32":
            return "uint";
        case "UInt64":
            return "ulong";
        case "Object":
            return "object";
        case "Void":
            return "void";
        default: 
            return type;
    }
}

public string FixUpTypeName(Type type)
{
    var ret = FixUpType(type);
    if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>))
    {
        ret = string.Format("{0}?", FixUpType(Nullable.GetUnderlyingType(type)));
    }
 
    else if (type.IsGenericType)
    {
        var inner = string.Empty;
        foreach (var t in type.GetGenericArguments())
        {
            if (t.IsGenericType)
            { 
                var outer1 = t.GetGenericTypeDefinition().FullName;
                var ary1 = outer1.Split(@"`".ToCharArray());
                outer1 = ary1[0];
 
                string inner1 = string.Empty;
                foreach (var t1 in t.GetGenericArguments())
                {
                    inner1 += t1.FullName;
                    inner1 += ",";
                }
                inner1 = inner1.TrimEnd(",".ToCharArray());
                inner += string.Format("{1}<{0}>", inner1, outer1);
            }
            else
            {
                inner += t.FullName;
                inner += ",";
            }
        }
        inner = inner.TrimEnd(",".ToCharArray());
        string name = FixUpType(type.GetGenericArguments()[0]);
        string outer = type.GetGenericTypeDefinition().FullName;
        string[] ary = outer.Split(@"`".ToCharArray());
        outer = ary[0];
        ret = string.Format("{1}<{0}>", inner, outer); 
    }
    else
    {
        return ret;
    }
 
    return ret;
}
#>