<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
//https://github.com/dotnet/core/issues/2000
<#@ assembly name="$(SolutionDir)\ExternalDependency\bin\Debug\netstandard2.0\ExternalDependency.dll" #>
<#@ import namespace="ExternalDependency" #>

<#
	string[] serviceList = { "ExternalService" };
    var assembly = Assembly.GetAssembly(typeof(ExternalService));
    var types = assembly.GetTypes();

	foreach (var classType in types.Where(x => serviceList.Contains(x.Name)))
    {
        string className = classType.Name;
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Generated on: <#=System.DateTime.Now.ToString()#>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------
using ExternalDependency;
using Mock.Dependency.With.Proxy.Apply.Strategy;
using Mock.Dependency.With.Proxy.Data.Transfer.Objects.Strategies;
using System;
using Unity;
using static Integration.Tests.ProjectWithProxy.IOCContainer;
using static Integration.Tests.ProjectWithProxy.ServiceMethodsStrategies.ServiceMethodsIdentifiers;

namespace Integration.Tests.ProjectWithProxy
{
	public class <#=(className+"ProxyBase")#> 
	{
		protected virtual Func<MockStrategy, bool> InWantedContext()
        {
            return s => { return true; };
        }
	}

	<#
		foreach(var meth in classType.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public))
		{
			var param = meth.GetParameters();
			var name = meth.Name;
			var returnType = FixUpTypeName(meth.ReturnType);
 
			StringBuilder parameterList = new StringBuilder();
			StringBuilder parameterListWithTypes = new StringBuilder();
			foreach(var p in param)
			{
				parameterList.Append(p.Name);
				parameterListWithTypes.Append(FixUpTypeName(p.ParameterType) + " " + p.Name);
				if(p != param.Last())
				{
					parameterList.Append(", ");
					parameterListWithTypes.Append(", ");
				}
			}
			#>
	public interface <#=className#><#=name#>Template
	{
		<#=returnType#> <#=name#>(<#=parameterListWithTypes#>);
	}
			<#
		}
	#>

	public partial class <#=(className+"Proxy")#> : <#=(className+"ProxyBase")#>, <#=className#>
    {
        private readonly <#=className#> service;
        private readonly MockStrategyRepository mockStrategyQuery;

        public ExternalServiceProxy(MockStrategyRepository mockStrategyQuery, <#=className#> service)
        {
            this.mockStrategyQuery = mockStrategyQuery;
            this.service = service;
        }

<#
		foreach(var meth in classType.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public))
		{
			var param = meth.GetParameters();
 
			var name = meth.Name;
			var returnType = FixUpTypeName(meth.ReturnType);
 
			StringBuilder parameterList = new StringBuilder();
			StringBuilder parameterListWithTypes = new StringBuilder();
			foreach(var p in param)
			{
				parameterList.Append(p.Name);
				parameterListWithTypes.Append(FixUpTypeName(p.ParameterType) + " " + p.Name);
				if(p != param.Last())
				{
					parameterList.Append(", ");
					parameterListWithTypes.Append(", ");
				}
			}
#>

		public <#=returnType#> <#=name#>(<#=parameterListWithTypes#>)
        {
           <#=returnType#> returnedValue;

            var mockStrategy = this.mockStrategyQuery.GetMockStrategy(GetId, this.InWantedContext());

            if (NoMockStrategy(mockStrategy))
            {
                returnedValue = this.service.Get();
            }
            else if (mockStrategy is ObjectStrategy<<#=returnType#>> objectStrategy)
            {
                returnedValue = objectStrategy.MockedObject;
            }
            else if (mockStrategy is SubstituteBehaviorStrategy methodStrategy)
            {
                returnedValue = ApplyMethodMockStrategy<#=name#>(methodStrategy);
            }
            else
            {
                throw new Exception("Current mock strategy is not take in account");
            }

            this.mockStrategyQuery.RemoveStrategy(mockStrategy);

            return returnedValue;
        }

		private static <#=returnType#> ApplyMethodMockStrategy<#=name#>(SubstituteBehaviorStrategy substituteBehaviorStrategy)
        {
            try
            {
                var serviceSubstitute = Container.Resolve<<#=className#><#=name#>Template>(substituteBehaviorStrategy.BehaviorName);
                return serviceSubstitute.<#=name#>();
            }
            catch (ResolutionFailedException)
            {
                throw new Exception($"Method strategy '{substituteBehaviorStrategy.BehaviorName}' is not defined");
            }
        }
<#
		}
#>
		
		private static bool NoMockStrategy(MockStrategy mockStrategy)
        {
            return mockStrategy is NoMockStrategy || mockStrategy is ForceNoMockStrategy;
        }
	}
}
<#
    }
#>    

<#+
void SaveOutput(string outputFileName)
{
    string templateDirectory = Path.GetDirectoryName(Host.TemplateFile);
    string outputFilePath = Path.Combine(templateDirectory, outputFileName);
    File.WriteAllText(outputFilePath, this.GenerationEnvironment.ToString()); 
 
    this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
}

public string FixUpType(Type t)
{
    string type = t.FullName;
    type = type.Replace("System.", "");
 
    switch (type)
    {
        case "String":
            return "string";
        case "Byte":
            return "byte";
        case "Byte[]":
            return "byte[]";
        case "Int16":
            return "short";
        case "Int32":
            return "int";
        case "Int64":
            return "long";
        case "Char":
            return "char";
        case "Single":
            return "float";
        case "Double":
            return "double";
        case "Boolean":
            return "bool";
        case "Decimal":
            return "decimal";
        case "SByte":
            return "sbyte";
        case "UInt16":
            return "ushort";
        case "UInt32":
            return "uint";
        case "UInt64":
            return "ulong";
        case "Object":
            return "object";
        case "Void":
            return "void";
        default: 
            return type;
    }
}

public string FixUpTypeName(Type type)
{
    var ret = FixUpType(type);
    if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>))
    {
        ret = string.Format("{0}?", FixUpType(Nullable.GetUnderlyingType(type)));
    }
 
    else if (type.IsGenericType)
    {
        var inner = string.Empty;
        foreach (var t in type.GetGenericArguments())
        {
            if (t.IsGenericType)
            { 
                var outer1 = t.GetGenericTypeDefinition().FullName;
                var ary1 = outer1.Split(@"`".ToCharArray());
                outer1 = ary1[0];
 
                string inner1 = string.Empty;
                foreach (var t1 in t.GetGenericArguments())
                {
                    inner1 += t1.FullName;
                    inner1 += ",";
                }
                inner1 = inner1.TrimEnd(",".ToCharArray());
                inner += string.Format("{1}<{0}>", inner1, outer1);
            }
            else
            {
                inner += t.FullName;
                inner += ",";
            }
        }
        inner = inner.TrimEnd(",".ToCharArray());
        string name = FixUpType(type.GetGenericArguments()[0]);
        string outer = type.GetGenericTypeDefinition().FullName;
        string[] ary = outer.Split(@"`".ToCharArray());
        outer = ary[0];
        ret = string.Format("{1}<{0}>", inner, outer); 
    }
    else
    {
        return ret;
    }
 
    return ret;
}
#>