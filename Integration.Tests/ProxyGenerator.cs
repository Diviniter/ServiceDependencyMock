//https://github.com/dotnet/core/issues/2000

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Generated on: 25/03/2019 10:06:36
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------
using ExternalDependencyForIntegrationTests;
using Mock.Dependency.With.Proxy.Apply.Strategy;
using Mock.Dependency.With.Proxy.Data.Transfer.Objects.Strategies;
using System;
using StructureMap;
using System.Reflection;
using static Integration.Tests.ProjectWithProxy.ServiceMethodsStrategies.ServiceMethodsIdentifiers;
using StructureMapConfigurationException = StructureMap.StructureMapConfigurationException;

namespace Integration.Tests.ProjectWithProxy
{
	
	public interface ExternalServiceGetTemplate
	{
		int Get();
	}
	
	public interface ExternalServiceSetTemplate
	{
		void Set(int i);
	}
	
	public interface ExternalServiceGetAsyncTemplate
	{
		System.Threading.Tasks.Task<System.Int32> GetAsync();
	}
	
	public interface ExternalServiceSetAsyncTemplate
	{
		void SetAsync(int i);
	}

	public partial class ExternalServiceProxy : ProxyBase, ExternalService
    {
        private readonly ExternalService service;
        private readonly MockStrategyRepository mockStrategyQuery;

        public ExternalServiceProxy(MockStrategyRepository mockStrategyQuery, ExternalService service)
        {
            this.mockStrategyQuery = mockStrategyQuery;
            this.service = service;
        }

		public  int Get()
        {
           int returnedValue;

            var mockStrategy = this.mockStrategyQuery.GetMockStrategy(GetId, this.InWantedContext());

            if (NoMockStrategy(mockStrategy))
            {
                returnedValue = this.service.Get();
            }
            else if (mockStrategy is ObjectStrategy<int> objectStrategy)
            {
                returnedValue = objectStrategy.MockedObject;
            }
            else if (mockStrategy is SubstituteBehaviorStrategy methodStrategy)
            {
                returnedValue = ApplyMethodMockStrategyGet(methodStrategy  );
            }
            else
            {
                throw new Exception("Current mock strategy is not take in account");
            }

            this.mockStrategyQuery.RemoveStrategy(mockStrategy);

            return returnedValue;
        }
		
		private static int ApplyMethodMockStrategyGet(SubstituteBehaviorStrategy substituteBehaviorStrategy  )
        {
			try
            {
                var serviceSubstitute = ProxyContainer.Container.GetInstance<ExternalServiceGetTemplate>(substituteBehaviorStrategy.BehaviorName);
				return serviceSubstitute.Get();
            }
            catch (StructureMapConfigurationException)
            {
                throw new Exception($"Method strategy '{substituteBehaviorStrategy.BehaviorName}' is not defined");
            }            
        }

		public  void Set(int i)
        {
            var mockStrategy = this.mockStrategyQuery.GetMockStrategy(SetId, this.InWantedContext());

            if (NoMockStrategy(mockStrategy))
            {
                this.service.Set(i);
            }
            else if (mockStrategy is SubstituteBehaviorStrategy methodStrategy)
            {
                ApplyMethodMockStrategySet(methodStrategy , i);
            }
            else
            {
                throw new Exception("Current mock strategy is not take in account");
            }

            this.mockStrategyQuery.RemoveStrategy(mockStrategy);
        }

		private static void ApplyMethodMockStrategySet(SubstituteBehaviorStrategy substituteBehaviorStrategy , int i)
        {
			try
            {
                var serviceSubstitute = ProxyContainer.Container.GetInstance<ExternalServiceSetTemplate>(substituteBehaviorStrategy.BehaviorName);
				serviceSubstitute.Set(i);
            }
            catch (StructureMapConfigurationException)
            {
                throw new Exception($"Method strategy '{substituteBehaviorStrategy.BehaviorName}' is not defined");
            }
        }

		public  System.Threading.Tasks.Task<System.Int32> GetAsync()
        {
           System.Threading.Tasks.Task<System.Int32> returnedValue;

            var mockStrategy = this.mockStrategyQuery.GetMockStrategy(GetAsyncId, this.InWantedContext());

            if (NoMockStrategy(mockStrategy))
            {
                returnedValue = this.service.GetAsync();
            }
            else if (mockStrategy is ObjectStrategy<System.Threading.Tasks.Task<System.Int32>> objectStrategy)
            {
                returnedValue = objectStrategy.MockedObject;
            }
            else if (mockStrategy is SubstituteBehaviorStrategy methodStrategy)
            {
                returnedValue = ApplyMethodMockStrategyGetAsync(methodStrategy  );
            }
            else
            {
                throw new Exception("Current mock strategy is not take in account");
            }

            this.mockStrategyQuery.RemoveStrategy(mockStrategy);

            return returnedValue;
        }
		
		private static System.Threading.Tasks.Task<System.Int32> ApplyMethodMockStrategyGetAsync(SubstituteBehaviorStrategy substituteBehaviorStrategy  )
        {
			try
            {
                var serviceSubstitute = ProxyContainer.Container.GetInstance<ExternalServiceGetAsyncTemplate>(substituteBehaviorStrategy.BehaviorName);
				return serviceSubstitute.GetAsync();
            }
            catch (StructureMapConfigurationException)
            {
                throw new Exception($"Method strategy '{substituteBehaviorStrategy.BehaviorName}' is not defined");
            }            
        }

		public  void SetAsync(int i)
        {
            var mockStrategy = this.mockStrategyQuery.GetMockStrategy(SetAsyncId, this.InWantedContext());

            if (NoMockStrategy(mockStrategy))
            {
                this.service.SetAsync(i);
            }
            else if (mockStrategy is SubstituteBehaviorStrategy methodStrategy)
            {
                ApplyMethodMockStrategySetAsync(methodStrategy , i);
            }
            else
            {
                throw new Exception("Current mock strategy is not take in account");
            }

            this.mockStrategyQuery.RemoveStrategy(mockStrategy);
        }

		private static void ApplyMethodMockStrategySetAsync(SubstituteBehaviorStrategy substituteBehaviorStrategy , int i)
        {
			try
            {
                var serviceSubstitute = ProxyContainer.Container.GetInstance<ExternalServiceSetAsyncTemplate>(substituteBehaviorStrategy.BehaviorName);
				serviceSubstitute.SetAsync(i);
            }
            catch (StructureMapConfigurationException)
            {
                throw new Exception($"Method strategy '{substituteBehaviorStrategy.BehaviorName}' is not defined");
            }
        }
		
		private static bool NoMockStrategy(MockStrategy mockStrategy)
        {
            return mockStrategy is NoMockStrategy || mockStrategy is ForceNoMockStrategy;
        }
	}
	
	public static class ProxyContainer
    {
        private static Container container;
	
        public static Container Container
        {
            get
            {
                if (container == null)
                {
                    container = new Container(c =>
                    {
                        c.Scan(_ =>
                        {
                            _.Assembly(Assembly.GetExecutingAssembly());
                            _.AddAllTypesOf<ExternalServiceGetTemplate>().NameBy(x => x.Name);
                            _.AddAllTypesOf<ExternalServiceSetTemplate>().NameBy(x => x.Name);
                            _.AddAllTypesOf<ExternalServiceGetAsyncTemplate>().NameBy(x => x.Name);
                            _.AddAllTypesOf<ExternalServiceSetAsyncTemplate>().NameBy(x => x.Name);
                        });
                    });
                }
	
                return container;
            }
        }
    }

}
    

